<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>三点水 | 假装自己是人类</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">三点水</a><span class="subtitle">假装自己是人类</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></div></header><article class="wrapper"><div class="container entries" id="index-main"><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-Why-should-bidirectional-associations-be-managed-manually/">QQA: Hibernate 为什么需要手工管理双向关联</a></div><div class="post-content"><p>Hibernate/JPA 中如果两个 Entity 之间的关联是双向的（不论是 <code>@ManyToMany</code>、
<code>@OneToMany</code> 还是 <code>@OneToOne</code>），都需要手动管理关联，为什么？</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JPA/">JPA</a><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/hibernate/">hibernate</a></div><div class="post-time">2018-07-28</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/HTML-5-Drag-and-Drop/">HTML 5 Drag and Drop 入门教程</a></div><div class="post-content"><p>在 HTML 5 之前，想要实现 Drag and Drop（拖拽/拖放）一般需要求助于 JQuery，所幸
HTML 5 已经把 DnD 标准化，现在我们能“轻易”地为几乎任意元素实现拖放功能。只是它的难度取决于你对 API 的理解程度，而<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">官方文档</a>并不好懂。这篇文章会一步步带你了解它的 API。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/DnD/">DnD</a><a class="post-tag-link" href="/tags/HTML5/">HTML5</a></div><div class="post-time">2018-07-21</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/kafka-introduction/">Kafka 入门介绍</a></div><div class="post-content"><p>Kafka 的大名相信大家早有耳闻，就是《变形记》的作者……咳咳……是一个著名的分布式消息队列，据说是因为作者特别喜欢作家卡夫卡才取名 Kafka 的。开始接触 Kafka 时最头疼的就是它的概念，什么是 group，什么是 partition …… 这里咱们从头开始理一理
Kafka 的基本概念。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Big-Data/">Big Data</a><a class="post-tag-link" href="/tags/Kafka/">Kafka</a></div><div class="post-time">2018-07-13</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/true-color-for-tmux-and-vim/">为 vim + tmux 开启真彩色(true color)</a></div><div class="post-content"><p>有一些 vim 主题（如 <a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">gruvbox</a> 或
<a href="https://github.com/lifepillar/vim-solarized8" target="_blank" rel="noopener">solarized8</a>）在 GUI 和终端下效果不同，有可能是因为这个主题需要 true color (24 位颜色) 的支持，而通常终端只开启 256 色的支持（如 <code>xterm-256color</code>）。下面来看看怎么开启 true color 支持。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/tmux/">tmux</a><a class="post-tag-link" href="/tags/vim/">vim</a></div><div class="post-time">2018-07-11</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/reactor-pattern/">Reactor 模式简介</a></div><div class="post-content"><p>如果你熟悉 Java 的 23 种设计模式，看到“Reactor 模式”可能就会一脸懵逼，这是什么鬼。Reactor 是一种应用在服务器端的开发模式（也有说法称 Reactor 是一种 IO 模式），目的是提高服务端程序的并发能力。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/asyncio/">asyncio</a><a class="post-tag-link" href="/tags/reactor/">reactor</a></div><div class="post-time">2018-06-28</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/how-big-is-2-power-128/">2^128 有多大</a></div><div class="post-content"><p>编程中，我们常常需要为“数据”指定 ID，那什么样的类型才“够大”呢？<code>int</code>? <code>long</code>?
<code>UUID</code>? 这篇文章里，咱们从直觉的角度聊一聊“数字”有多大。</p></div><div class="post-meta"><div class="post-time">2018-06-27</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/rargs/">分享创造 rargs</a></div><div class="post-content"><p><a href="https://github.com/lotabout/rargs" target="_blank" rel="noopener">rargs</a> 是一个 rust 实现的命令行工具，它解
决的是 <code>xargs</code> 或 <code>parallel</code> 等批量处理工具中无法自由引用输入的痛点。<code>rargs</code>
支持用正则表达式来匹配输入中的任意内容。例如，我们想恢复一些以 <code>.bak</code> 结尾的备
份文件，用 <code>rargs</code> 可以这么做：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls *.bak | rargs -p <span class="string">'(.*)\.bak'</span> mv &#123;0&#125; &#123;1&#125;</span><br></pre></td></tr></table></figure></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/rargs/">rargs</a><a class="post-tag-link" href="/tags/xargs/">xargs</a></div><div class="post-time">2018-04-14</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/Understanding-Python-MetaClass/">Python 元类 (MetaClass) 小教程</a></div><div class="post-content"><p>可能是 Ruby 带的头，大家喜欢把“元编程”称作魔法，其实哪有什么魔法，一切都是科学。而 meta classes 就是 Python 里最魔法的科学，也是 99% 的人用不到的科学。只是谁还不想学点魔法呢？</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/meta-programming/">meta-programming</a><a class="post-tag-link" href="/tags/python/">python</a></div><div class="post-time">2018-04-06</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-Python-str-vs-repr/">QQA: Python 中的 str 与 repr</a></div><div class="post-content"><p>有时候，你会需要为你的类实现 <code>__str__</code> 或 <code>__repr__</code> 方法，你知道它们的作用
是什么吗？它们有什么区别吗？这个问题的答案一搜就能找到，如果恰巧这是你第一次看
到这个问题，不妨看看吧。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/python/">python</a><a class="post-tag-link" href="/tags/repr/">repr</a><a class="post-tag-link" href="/tags/str/">str</a></div><div class="post-time">2018-04-04</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-why-use-getters-and-setters/">QQA: 为什么 java 中要写 getter/setter？</a></div><div class="post-content"><p>java 有一个不成文的规定，如果要访问一个类的 private 字段，就需要写
getter/setter 方法。但我们在其它语言却很少见到类似的约定，为什么？</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/java/">java</a></div><div class="post-time">2018-04-02</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-send-vs-sync-in-rust/">QQA: Rust 中 Send 与 Sync 有什么区别</a></div><div class="post-content"><p><code>Send</code> 与 <code>Sync</code> 是两个十分相近的 trait，它们是一起保证了 Rust 的线程安全，它
们又有什么异同点呢？</p>
<p>（Quick Question and Answer 系列旨在对小问题做简短解答）</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/rust/">rust</a></div><div class="post-time">2018-04-01</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-What-is-servlet/">QQA: 什么是 Servlet</a></div><div class="post-content"><p>Servlet 没有标准的中文译名，我们会在学习 Java Web 编程（如 Spring）时遇到，你知道它是什么吗？</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/java/">java</a><a class="post-tag-link" href="/tags/servlet/">servlet</a></div><div class="post-time">2018-03-31</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/QQA-How-to-enable-autowire/">QQA: 如何启用 @Autowired</a></div><div class="post-content"><p><code>@Autowired</code> 是 Spring 提供的一个注解，作用是自动装配 Bean 所需要的依赖。但
<code>@Autowired</code> 只是告诉 Spring 当前的 Bean 依赖了其它的 Bean，那么如何让 Spring
真正“启用”自动装配的功能呢？</p>
<p>（Quick Question and Answer 系列旨在对小问题做简短解答）</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/QQA/">QQA</a><a class="post-tag-link" href="/tags/autowire/">autowire</a><a class="post-tag-link" href="/tags/java/">java</a></div><div class="post-time">2018-03-30</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/WGAN/">WGAN 笔记</a></div><div class="post-content"><p>Wasserstein GAN(WGAN) 解决传统 GAN 的训练难，训练过程不稳定等问题了。WGAN 的背后有强劲的数学支撑，因此要想理解这它的原理，需要理解许多数学公式的推导。这个笔记尽量尝试从直觉的角度来理解 WGAN 背后的原理。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/GAN/">GAN</a><a class="post-tag-link" href="/tags/Machine-Learning/">Machine Learning</a><a class="post-tag-link" href="/tags/WGAN/">WGAN</a></div><div class="post-time">2018-03-29</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/f-divergence-GAN/">ƒ-divergence GAN 笔记</a></div><div class="post-content"><p>f-divergence GAN 是对 GAN 框架的理论统一，本文学习过程中的一些笔记，包括基本公式的推导和重要概念的理解。</p>
<p>学习资料是李宏毅老师 <a href="https://www.youtube.com/watch?v=KSN4QYgAtao&amp;lc=z13kz1nqvuqsipqfn23phthasre4evrdo" target="_blank" rel="noopener">关于 WGAN 的教学视频
</a>
视频里深入浅出地介绍了许多 GAN 的相关知识。不需要太多的数学基础就能听懂，强力
推荐。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/GAN/">GAN</a><a class="post-tag-link" href="/tags/Machine-Learning/">Machine Learning</a></div><div class="post-time">2018-03-29</div></div></div></div></div></article><footer class="footer wrapper"><div class="social"><a href="mailto:lotabout@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/lotabout" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer-content">© 2018 <a href="/" rel="nofollow">三点水</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/hexo-theme-noise">noise</a>.</div></footer><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="/js/noise.js"></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>
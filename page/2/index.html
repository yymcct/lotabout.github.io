<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>三点水 | 假装自己是人类</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">三点水</a><span class="subtitle">假装自己是人类</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></div></header><article class="wrapper"><div class="container entries" id="index-main"><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/Back-Propagation-Note/">Back Propagation 笔记</a></div><div class="post-content"><p>Michael Nielsen 的 <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">深度学习
</a> 文章里对 BP 算法有了相当全面的介绍，网上也有中文翻译版本。本文是自己学习的一些笔记，主要是抄一遍公式的证明来加强记忆。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Machine-Learning/">Machine Learning</a><a class="post-tag-link" href="/tags/Neural-Network/">Neural Network</a></div><div class="post-time">2018-03-13</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/Logistic-Regression-Notes/">逻辑回归实验</a></div><div class="post-content"><p>最近在看 Andrew Ng 老师的 <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">机器学习课程
</a>，这篇文章试图通过编程的方式，一步步实验课程中的知识点，验证其中的一些结论，从而加深对逻辑回归的理解。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Logistic/">Logistic</a><a class="post-tag-link" href="/tags/Machine-Learning/">Machine Learning</a><a class="post-tag-link" href="/tags/Regression/">Regression</a></div><div class="post-time">2018-03-10</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/performance-optimization/">性能优化三件套</a></div><div class="post-content"><p>提高性能最怕是没有方向，没有头绪的时候不妨试试三件套：并行、异步、加缓存。</p></div><div class="post-meta"><div class="post-time">2018-03-05</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/decision-tree/">决策树 (decision tree)</a></div><div class="post-content"><p>通过训练，我们可以从样本中学习到决策树，作为预测模型来预测其它样本。两个问题：</p>
<ol>
<li>我们说要训练/学习，训练/学习什么？</li>
<li>为什么决策树可以用来预测？或者说它的泛化能力的来源是哪？</li>
</ol></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Statistics/">Statistics</a><a class="post-tag-link" href="/tags/decision-tree/">decision tree</a></div><div class="post-time">2018-03-02</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/kernel-density-estimation/">核密度估计（kernel density estimation）</a></div><div class="post-content"><p>有一些数据，想“看看”它长什么样，我们一般会画直方图（Histogram）。现在你也可以用核密度估计。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/KDE/">KDE</a><a class="post-tag-link" href="/tags/Statistics/">Statistics</a></div><div class="post-time">2018-02-27</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/segment-tree/">线段树 (区间树)</a></div><div class="post-content"><p>不查不知道，一查吓一跳，“线段树”这个名字的定义真是混乱到一定程度了。</p>
<p>维基百科 <a href="https://en.wikipedia.org/wiki/Segment_tree" target="_blank" rel="noopener">Segment Tree</a> 说它是一种
数据结构，用来存储区间或线段，用来在 <code>O(log n)</code> 的时间内查找包含某个点的所有区
间。一般线段树是静态的结构，不需要修改的，但一些教程又很强调线段树的修改，比如
说“lazy 节点是线段树的精髓“。与此同时，另一种结构区间树(<a href="https://en.wikipedia.org/wiki/Interval_tree" target="_blank" rel="noopener">Interval
Tree</a>) 在结构和功能上和线段树又十
分接近。看来看去，线段树，区间树在维基百科、教材、博客里的介绍经常大不相同。</p>
<p>本文里，我们以解决区间最小值(RMQ)问题中使用的数据结构为基准，讲讲“线段树”的基本思想。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Data-Structure/">Data Structure</a></div><div class="post-time">2018-02-08</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/binary-indexed-tree/">二叉索引树</a></div><div class="post-content"><p>二叉索引树(Binary Indexed Tree) 也称为 <a href="https://en.wikipedia.org/wiki/Fenwick_tree" target="_blank" rel="noopener">Fenwick
tree</a>，中文也称树状数组。它可以在
O(log n) 的时间内得到数组的前缀和(A[1] + A[2] + … + A[i])，且在 O(log n) 时间内支持动态修改数组的值。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Data-Structure/">Data Structure</a></div><div class="post-time">2018-01-29</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/Git-merge-vs-rebase/">Git: merge vs rebase</a></div><div class="post-content"><p>Merge 还是 Rebase，这是一个问题。网上有许多教程说明二者的区别，之前我写的一个
<a href="https://docs.google.com/presentation/d/18b-ehlVjU82_PzU64lkbVwkzPsK3T2yENmjwwL7FVfM/edit" target="_blank" rel="noopener">关于 Git 的 PPT</a>
里也说过两者的区别。这篇文章里，我们从分支图的角度，看看两种策略下产生的分支图有什么区别。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Git/">Git</a></div><div class="post-time">2018-01-18</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/think-twice-before-utilizing-meta-programming/">不要轻易使用元编程</a></div><div class="post-content"><p>元编程就像核弹，自己梦寐以求，却不希望别人拥有。</p>
<p>一般说元编程分为两类，一类是宏，在编译时期生成代码；另一类是运行时修改代码的行
为。而不论是哪一类，我的建议是在决定使用之前要慎重考虑。元编程能让我们扩展语言
本身，是十足的黑魔法；但用好不易，容易造成团队/社区在意见是实现上的分裂。（另
外这篇文章里主要是对元编程的一些吐糟，并不包含基础知识的介绍。）</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/macro/">macro</a><a class="post-tag-link" href="/tags/meta-programming/">meta-programming</a></div><div class="post-time">2018-01-07</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/Dependency-Inversion-Principle/">DIP vs IoC vs DI</a></div><div class="post-content"><p>你听过 SOLID 设计原则吗？你了解 Spring 里的控制反转（IoC）吗？你知道依赖注入（Dependency Injection）和它们有什么区别吗？虽然它们的形式多样，但内核却是简单的概念。我们就来看看它们到底是什么。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Dependency-Injection/">Dependency Injection</a><a class="post-tag-link" href="/tags/Dependency-Inversion-Principle/">Dependency Inversion Principle</a><a class="post-tag-link" href="/tags/Inversion-of-Control/">Inversion of Control</a><a class="post-tag-link" href="/tags/SOLID/">SOLID</a></div><div class="post-time">2018-01-03</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/Notes-on-Java-Annotation-Processor/">Java Annotation Processor 小记</a></div><div class="post-content"><p>最近基于工作上的需求调研了下 Java Annotation Processor 的使用方式，开篇博客记录下学习过程中遇到的坑。可以由于平时用到 Annotation 的场景特别少，因此能搜索到的教程特别有限，也希望文章在某种程度上填补部分空白吧。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Annotation/">Annotation</a><a class="post-tag-link" href="/tags/Java/">Java</a></div><div class="post-time">2017-12-31</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/Shorten-Feedback-Loop/">及时获取反馈以提升工作效率</a></div><div class="post-content"><p>最近发现自己及整个团队的开发效率低下，思前想后认为跟反馈链太长脱不了干系，于是思考及时反馈的重要性，以及它如何影响我们的效率。这里做一个小结。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/efficiency/">efficiency</a><a class="post-tag-link" href="/tags/feedback/">feedback</a></div><div class="post-time">2017-11-19</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/Estimate-Rice-Production-In-History/">估算：古代水稻亩产量</a></div><div class="post-content"><p>用了金克垃，亩产一千八。古代没有金克垃，亩产有多少？有你现有的常识，能估算出来吗？</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Estimation/">Estimation</a></div><div class="post-time">2017-11-03</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/flex-shrink-in-order/">CSS 子元素依次收缩的实现</a></div><div class="post-content"><p>当子元素的宽度（或高度）超过父元素时，如果父元素设置了 <code>display: flex</code>，则子
元素将按比例缩小自己的宽度（或高度），但现在我们希望子元素按一定的优先级缩小。
即：当宽度不足时，优先缩小某一个子元素，当达到该元素的最小宽度（<code>min-width</code>）
时，再开始缩小另外的元素。下面是一个示例图：</p>
<img src="/2017/flex-shrink-in-order/expected.gif" title="Expected Behavior">
<p>可以看到，当宽度不足时，上例中优先缩小了最右的元素，当最右元素达到最小宽度
100px 时开始缩小左边的元素，依此类推。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/css/">css</a><a class="post-tag-link" href="/tags/flex-shrink/">flex-shrink</a></div><div class="post-time">2017-09-29</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/Python-Decorator/">Python Decorator(装饰器)</a></div><div class="post-content"><p>今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/decorator/">decorator</a><a class="post-tag-link" href="/tags/python/">python</a></div><div class="post-time">2017-09-29</div></div></div></div></div></article><footer class="footer wrapper"><div class="social"><a href="mailto:lotabout@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/lotabout" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer-content">© 2018 <a href="/" rel="nofollow">三点水</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/hexo-theme-noise">noise</a>.</div></footer><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="/js/noise.js"></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>